NOTES
Liuyin Shi

2023-11-17
This note is created for you for testing purposes

1. To run this application, you need to stat postgres database first, and make sure 
ther is a user named guest and passwor guest set

2. Please create a database named traildb, we will store all zones, trails and shelters
in this database.

3. In the main.go, I created several trails, zones and shelters. They are based on the 
real-worl location data around mcmaster (Inside the InitializeDB function), i will have 
them listed below. The names are very intuitive and you chekc them out in google map

4 For sending from the trail manager to the workout service thru the queue, the name is 
configured in config.go, the name is inside the Publish struct, variable named Destination
on line 52, you can change it to the other name based on your need


5. Some quickcuts when droping table in postgres

delete tables for fresh start
DROP TABLE traildb.shelter CASCADE;
DROP TABLE traildb.trail CASCADE;
DROP TABLE traildb.zone CASCADE;


6. MockData is shown below:
zones
		McMaster Zone
		Fortinos Zone
		Westdale Zone

Trails

		 McMaster Zone, "Starbucks Trail", 43.257538, -79.919628, 43.257903, -79.912135
		 McMaster Zone, "ITB Trail", 43.258524, -79.921946, 43.262500, -79.923594
		 Fortinos Zone, "Fortinos Trail", 43.256875, -79.930235, 43.250969, -79.928593
		 Fortinos Zone, "Church Trail", 43.252870, -79.929062, 43.250162, -79.928219
		 Westdale Zone, "Westdale UPS Trail", 43.260574, -79.909137, 43.263184, -79.902858
		 Westdale Zone, "Westdale TD Trail", 43.263325, -79.902569, 43.262191, -79.897021
		 Westdale Zone, "Churchill Park Trail", 43.269293, -79.899137, 43.264866, -79.897739

Shelters
		 "McMaster Shelter1", Starbucks Trail, availabilty:true, 43.257540, -79.918279
		 "McMaster Shelter2", Starbucks Trail, availabilty:false, 43.257616, -79.915874
		 "Fortinos Shelter", Fortinos Trail, availabilty:true, 43.254928, -79.929630
		 "Westdale Shelter", Churchill Park Trail, availabilty: true, 43.263117, -79.901379

The backup of the printDB and InitializeDB functions:
func printTableData(db *sql.DB, tableName string) {
	// Check if the table is empty
	var count int
	err := db.QueryRow(fmt.Sprintf("SELECT COUNT(*) FROM %s", tableName)).Scan(&count)
	if err != nil {
		log.Fatal("Error counting rows in print", zap.Error(err))
	}

	// If the table is not empty, print its contents
	if count > 0 {
		rows, err := db.Query(fmt.Sprintf("SELECT * FROM %s", tableName))
		if err != nil {
			// log.Fatalf("Error querying data from %s: %v", tableName, err)
		}
		defer rows.Close()

		cols, err := rows.Columns()
		if err != nil {
			// log.Fatalf("Error getting columns from %s: %v", tableName, err)
		}

		values := make([]interface{}, len(cols))
		pointers := make([]interface{}, len(cols))
		for i := range values {
			pointers[i] = &values[i]
		}

		for rows.Next() {
			err := rows.Scan(pointers...)
			if err != nil {
				// log.Fatal(err)
			}

			for i, colName := range cols {
				val := pointers[i].(*interface{})
				fmt.Printf("%s: %v ", colName, *val)
			}
			fmt.Println()
		}
		if err = rows.Err(); err != nil {
			// log.Fatal(err)
		}
	} else {
		fmt.Printf("The table %s is empty.\n", tableName)
	}
}

func initializeDB() {
	num, err := strconv.Atoi(cfg.Postgres.Port)
	if err != nil {
		// Handle the error if the string cannot be converted to an integer
		fmt.Println("Error:", err)
		return
	}
	connStr := fmt.Sprintf("host=%s port=%d user=%s password=%s dbname=%s sslmode=disable",
		cfg.Postgres.Host, num, cfg.Postgres.User, cfg.Postgres.Password, cfg.Postgres.DB_Name)
	db, err := sql.Open("postgres", connStr)
	if err != nil {
		// log.Fatal(err)
		fmt.Println("Error:", err)
	}
	defer db.Close()

	// Check the connection
	err = db.Ping()
	if err != nil {
		log.Fatal("database cant be connected", zap.Error(err))
	}
	fmt.Println("Successfully connected!")

	// Create a new schema
	_, err = db.Exec("CREATE SCHEMA IF NOT EXISTS traildb AUTHORIZATION guest")
	if err != nil {
		log.Fatal("jkjk", zap.Error(err))
	}
	fmt.Println("Schema created.")

	// Grant all privileges on the schema to the user
	_, err = db.Exec("GRANT ALL PRIVILEGES ON SCHEMA traildb TO guest")
	if err != nil {
		log.Fatal("database access cant be granted", zap.Error(err))
	}
	fmt.Println("Privileges granted to user 'guest'.")

	// Create tables
	_, err = db.Exec(`
        CREATE TABLE IF NOT EXISTS traildb.zone (
            zone_id UUID PRIMARY KEY,
            zone_name TEXT NOT NULL
        )`)
	if err != nil {
		log.Fatal("Error creating zone table", zap.Error(err))
	}

	_, err = db.Exec(`
        CREATE TABLE IF NOT EXISTS traildb.trail (
            trail_id UUID PRIMARY KEY,
            trail_name TEXT NOT NULL,
            zone_id UUID REFERENCES traildb.zone(zone_id),
            start_longitude FLOAT,
            start_latitude FLOAT,
            end_longitude FLOAT,
            end_latitude FLOAT,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )`)
	if err != nil {
		log.Fatal("cannot inser to the trail table", zap.Error(err))
	}

	_, err = db.Exec(`
        CREATE TABLE IF NOT EXISTS traildb.shelter (
            shelter_id UUID PRIMARY KEY,
            shelter_name TEXT NOT NULL,
            trail_id UUID REFERENCES traildb.trail(trail_id),
            shelter_availability BOOLEAN NOT NULL,
            longitude FLOAT,
            latitude FLOAT,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )`)
	if err != nil {
		log.Fatal("Error creating shelter table", zap.Error(err))
	}

	fmt.Println("Table created.")

	// Insert two shelters with distinct names and locations

	zones := []struct {
		ID   uuid.UUID
		Name string
	}{
		{uuid.New(), "McMaster Zone"},
		{uuid.New(), "Fortinos Zone"},
		{uuid.New(), "Westdale Zone"},
	}

	// Insert four trails with distinct names and start/end longitudes
	trails := []struct {
		ID       uuid.UUID
		ZoneID   uuid.UUID
		Name     string
		StartLon float64
		StartLat float64
		EndLon   float64
		EndLat   float64
	}{
		{uuid.New(), zones[0].ID, "Starbucks Trail", 43.257538, -79.919628, 43.257903, -79.912135},
		{uuid.New(), zones[0].ID, "ITB Trail", 43.258524, -79.921946, 43.262500, -79.923594},
		{uuid.New(), zones[1].ID, "Fortinos Trail", 43.256875, -79.930235, 43.250969, -79.928593},
		{uuid.New(), zones[1].ID, "Church Trail", 43.252870, -79.929062, 43.250162, -79.928219},
		{uuid.New(), zones[2].ID, "Westdale UPS Trail", 43.260574, -79.909137, 43.263184, -79.902858},
		{uuid.New(), zones[2].ID, "Westdale TD Trail", 43.263325, -79.902569, 43.262191, -79.897021},
		{uuid.New(), zones[2].ID, "Churchill Park Trail", 43.269293, -79.899137, 43.264866, -79.897739},
	}

	shelters := []struct {
		ID      uuid.UUID
		Name    string
		TrailID uuid.UUID
		Avail   bool
		Lon     float64
		Lat     float64
	}{
		{uuid.New(), "McMaster Shelter1", trails[0].ID, true, 43.257540, -79.918279},
		{uuid.New(), "McMaster Shelter2", trails[0].ID, false, 43.257616, -79.915874},
		{uuid.New(), "Fortinos Shelter", trails[2].ID, true, 43.254928, -79.929630},
		{uuid.New(), "Westdale Shelter", trails[5].ID, true, 43.263117, -79.901379},
	}

	// Insert initial data into zone table
	// Note: Adjust the UUIDs to your preference or generate them programmatically
	var zoneCount int
	err = db.QueryRow("SELECT COUNT(*) FROM traildb.zone").Scan(&zoneCount)
	if err != nil {
		log.Fatal("error counting zones: %v", zap.Error(err))
	}
	if zoneCount < len(zones) {
		for _, zone := range zones {
			_, err := db.Exec(`
            INSERT INTO traildb.zone (zone_id, zone_name) VALUES ($1, $2)
            ON CONFLICT (zone_id) DO NOTHING`,
				zone.ID, zone.Name)
			if err != nil {
				log.Fatal("Error inserting zone", zap.Error(err))
			}
		}
	}

	fmt.Println("inserted zones.")

	var trailCount int
	err = db.QueryRow("SELECT COUNT(*) FROM traildb.trail").Scan(&trailCount)
	if err != nil {
		log.Fatal("error counting trails: %v", zap.Error(err))
	}

	// Create a table within the schema
	if trailCount < len(trails) {
		for _, trail := range trails {
			_, err := db.Exec(`
            INSERT INTO traildb.trail (trail_id, trail_name, zone_id, start_longitude, start_latitude, end_longitude, end_latitude)
            VALUES ($1, $2, $3, $4, $5, $6, $7)
            ON CONFLICT (trail_id) DO NOTHING`,
				trail.ID, trail.Name, trail.ZoneID, trail.StartLon, trail.StartLat, trail.EndLon, trail.EndLat)
			if err != nil {
				log.Fatal("Error inserting trail", zap.Error(err))
			}
		}
	}

	fmt.Println("inserted trails.")
	var shelterCount int
	err = db.QueryRow("SELECT COUNT(*) FROM traildb.shelter").Scan(&shelterCount)
	if err != nil {
		log.Fatal("error counting shelters: %v", zap.Error(err))
	}
	if shelterCount < len(shelters) {
		for _, shelter := range shelters {
			_, err := db.Exec(`
            INSERT INTO traildb.shelter (shelter_id, shelter_name, trail_id, shelter_availability, longitude, latitude)
            VALUES ($1, $2, $3, $4, $5, $6)
            ON CONFLICT (shelter_id) DO NOTHING`,
				shelter.ID, shelter.Name, shelter.TrailID, shelter.Avail, shelter.Lon, shelter.Lat)
			if err != nil {
				log.Fatal("Error inserting shelter", zap.Error(err))
			}
		}
	}

	// printTableData(db, "traildb.shelter")
	// printTableData(db, "traildb.trail")
}

// ensureDatabaseExists checks for the existence of the database and creates it if it doesn't exist
func ensureDatabaseExists(cfg *config.Postgres) error {
	// Connection string without the database name
	psqlInfo := fmt.Sprintf("host=%s port=%s user=%s password=%s sslmode=disable",
		cfg.Host, cfg.Port, cfg.User, cfg.Password)

	// Open a connection to the database server
	db, err := sql.Open("postgres", psqlInfo)
	if err != nil {
		return err
	}
	defer db.Close()

	// Check if the database exists
	var exists bool
	query := `SELECT EXISTS(SELECT 1 FROM pg_database WHERE datname=$1);`
	err = db.QueryRow(query, cfg.DB_Name).Scan(&exists)
	if err != nil {
		return err
	}

	// If the database does not exist, create it
	if !exists {
		_, err = db.Exec(fmt.Sprintf("CREATE DATABASE %s;", cfg.DB_Name))
		if err != nil {
			return err
		}
	}

	return nil
}
